# Table of contents
- [사용자 수에 따른 규모 확장성](#----)
    - [단일 서버](#-)
    - [데이터베이스](#)
        - [어떤 데이터베이스를 사용할 것인가?](#---)
    - [수직적 규모 확장 vs 수평적 규모 확장](#---vs---)
        - [로드밸런서](#)
        - [데이터베이스 다중화](#-)
    - [캐시](#)
        - [캐시 계층](#-)
        - [캐시 사용 시 유의할 점](#----)
    - [콘텐츠 전송 네트워크(CDN)](#--cdn)
        - [CDN 사용 시 고려해야 할 사항](#cdn-----)
    - [무상태(stateless) 웹 계층](#stateless--)
        - [상태 정보 의존적인 아키텍처](#---)
        - [무상태 아키텍처](#-)
    - [데이터 센터](#-)
    - [메시지 큐](#-)
    - [로그, 메트릭 그리고 자동화](#---)
        - [메시지 큐, 로그, 메트릭, 자동화 등을 반영하여 수정한 설계안](#--------)
    - [데이터베이스의 규모 확장](#--)
        - [수직적 확장](#-)
        - [수평적 확장](#-)
    - [백만 사용자, 그리고 그 이상](#----)

# 사용자 수에 따른 규모 확장성

## 단일 서버

- 한 대에서 서버, 데이터베이스, 캐시 등을 모두 실행


1. 도메인 이름으로 DNS 질의 -> IP 주소
2. IP 주소로 서버에게 요청
3. 서버는 HTML 또는 API 응답

## 데이터베이스

- 사용자가 늘면 트래픽 처리용 서버와 DB 서버를 분리
- 덕분에 각각을 독립적으로 확장 가능

### 어떤 데이터베이스를 사용할 것인가?

- RDB
    - 자료를 테이블과 열, 칼럼으로 표현
    - SQL을 사용해 여러 테이블에 있는 데이터를 조인 연산
- NoSQL
    - 비 관계형 데이터베이스
    - 일반적으로 4가지 종류
        - key-value store
        - graph store
        - column store
        - document store
    - 일반적으로 조인 연산을 지원 X 혹은 권장 X

- 일반적으로 대부분의 시스템에는 RDB가 적합하지만 아래와 같은 경우 비-관계형 DB가 바람직할 수도 있다
    - 아주 낮은 응답 지연 시간 요구
    - 데이터가 비정형이라 관계형 데이터가 아님
    - 데이터를 직렬화/역직렬화 하는 것만 있으면 됨
    - 아주 많은 데이터를 저장할 필요가 있다

## 수직적 규모 확장 vs 수평적 규모 확장

- 스케일 업
    - 서버에 더 고사양의 자원을 투자해 성능 개선
- 스케일 아웃
    - 더 많은 서버 추가해서 성능 개선

- 트래픽의 양이 적을 때는 수직적 확장이 좋은 선택
    - 그 이유는 단순함때문이지만 몇 가지 심각한 단점이 있다

- 수직적 확장의 단순함
    - 규모 확장에 한계 존재
    - 수직적 규모 확장 자체만으로는 failover나 다중화 방안을 제시하지 않는다

- 따라서 일반적으로 대규모 애플리케이션에서는 수평적 규모 확장법이 적절하다

### 로드밸런서

- 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산
- LB를 사용하면 클라이언트는 LB의 IP 주소로 접속하므로 사용자에게 웹 서버를 숨길 수 있다
    - 서버 간 통신에는 사설 IP를 이용

- LB가 정상 상태인 서버들에게만 트래픽을 전달하므로 failover 문제는 해결할 수 있으며, 덕분에 웹 계층의 가용성을 올릴 수 있다
- 트래픽이 증가하면 그에 맞게 서버를 증설할 수 있다

- 그러나 여전히 데이터베이스 서버는 하나이므로 데이터 계층의 failover나 다중화 문제가 존재한다

> client side load balancer vs server side load balancer

- Client Side LB
    - LB와 같은 장애 지점 x
    - LB 비용 절감
    - LB 통하지 않으므로 네트워크 지연 시간 감소
- Server Side LB
    - 클라이언트 설정 간단
    - 모든 트래픽은 LB를 통한다
        - 클라이언트는 서버 모름

### 데이터베이스 다중화

- 일반적으로 많이 사용하는 방식은 master-slave 관계를 설정하고, 데이터 원본은 master에, 사본은 slave에 저장하는 방식이다

- 쓰기 연산은 마스터에서만 지원하며, 복제본은 읽기 연산을 지원
- 대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 많다

- 이러한 구성의 장점은 다음과 같다
    - 읽기 요청을 여러 DB 서버에 분산시킬 수 있으므로 한 번에 더 많은 쿼리를 처리할 수 있어서 성능적으로 이득을 볼 수 있다
    - DB 일부에 문제가 생기더라도 데이터는 보존될 것이다
    - DB 일부에 문제가 생겨도 다른 DB 서버가 대신 서비스 할 수 있다

- 단, 마스터 DB가 죽은 경우 단순히 복제본 DB가 승격되고 끝나는 것이 아니라 최선을 다해 데이터를 복구하기 위해 추가적인 과정이 필요하다. 이 과정에서 시간이 소요된다

> 다중 마스터, 원형 다중화

- Multi Master
    - Active-Active 구성
    - 한 Writer가 다운되어도 다른 Writer가 작동할 수 있도록
    - 단, 트랜잭션 충돌이 발생할 수 있다
        - 레코드 단위? 페이지 단위?

- Circular Replication
    - 고가용성, 확장성
    - 단, Multi Master보다 더 큰 지연시간
        - 이로 인해 충돌 확률이 올라감
        - 쓰기 일관성 문제

## 캐시

- 캐시를 두는 이유
    - DB보다 훨씬 빠르다
    - DB로 가는 요청의 수를 줄여 DB의 부하 줄이기
    - 캐시 계층의 규모를 독립적으로 확장하는 것 또한 가능

> 캐시 전략

[Caching patterns - Database Caching Strategies Using Redis](https://docs.aws.amazon.com/ko_kr/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html)

- Write Through
    - 캐시, DB에 모두 항상 업데이트
    - 장점
        - 데이터베이스와 캐시 데이터 일관성
    - 단점
        - 쓰기 연산이 무거워진다
        - 자주 사용되지 않는 데이터도 캐시에 올라갈 확률이 높다
    - 언제 사용?
        - 캐시 데이터 일관성 중요할 때
        - 쓰기 지연 괜찮을 때
- Write Back (Write Behind)
    - Write Through와 비슷하지만
    - 일단 캐시에만 쓰고
    - 비동기적으로 DB에 업데이트
- Cache Aside (Look Aside)
    - 캐시에서 먼저 확인, 없으면 DB에서 가져와서 저장
        - 장점
            - 필요없는 데이터가 캐싱되는 것 방지
        - 단점
            - 캐시 미스나면 지연 시간 커진다
            - 데이터가 자주 업데이트되면 캐시 무용
        - 언제 사용?
            - 캐시 미스 비용 크지 않을 때
            - 캐시 미스가 드물 때
            - 데이터가 자주 업데이트 되지 않을 때
- Read Through
    - Cache Aside와 비슷하지만 캐시 미스가 발생했을 때 캐시에 데이터를 적재하는 책임을 캐시가 가진다
    - 장점
        - 캐시가 데이터 로딩을 담당하므로 클라이언트가 간단, 일관
    - 단점
        - Cache Aside와 같다

### 캐시 계층

### 캐시 사용 시 유의할 점

- 일반적으로 데이터 전송이 자주 일어나지 않지만 참조는 빈번하게 일어날 때
- 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다
- 캐시에 보관된 데이터를 어떻게 만료시킬 것인가?
    - 너무 짧으면 캐시를 제대로 활용하지 못하므로 그것도 곤란하다
- 일관성은 어떻게 유지하는가?
- 캐시의 장애는 어떻게 대처할 것인가?
- 캐시 메모리는 얼마나 크게 잡을 것인가?
    - 너무 작으면 evicition이 너무 자주 발생할 수 있다
- evicition 정책은 무엇인가?
    - LRU, LFU, FIFO 등등

[MIT 6.824: Lecture 16 - Scaling Memcache at Facebook](https://timilearning.com/posts/mit-6.824/lecture-16-memcache-at-facebook/)
[Scaling Memcache At Facebook - CH DEVLOG](https://changhoi.kim/posts/database/scaling-memcache-at-facebook/)

## 콘텐츠 전송 네트워크(CDN)

- 일반적으로 정적 콘텐츠를 전송하는 데 쓰인다
- 지리적으로 분산된 서버의 네트워크

- 동적 콘텐츠 캐싱은 요청 경로, query string, 헤더 등의 정보에 기반해서 캐시하는 방식

> CDN 관련 장애 대응 글이나 post moterm을 찾아보려 했는데 마땅한 게 안 보이는군요ㅠ

[CloudFront 오리진 장애 조치를 통한 고가용성 최적화 - Amazon CloudFront](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/high_availability_origin_failover.html)

### CDN 사용 시 고려해야 할 사항

- 비용
    - 보통 CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금
    - 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않다
- 적절한 만료 시한
    - 너무 길면 원본 콘텐츠와의 차이가 커지고 너무 짧으면 CDN으로 얻을 수 있는 이득이 줄어든다
- CDN 장애 대처 방안
- 콘텐츠 무효화 방법
    - 아직 만료되지 않은 콘텐츠라도 경우에 따라서 CDN에서 제거할 수 있는 방법이 필요
        - CDN 서비스 사업자의 API 사용
        - 혹은 오브젝트 버저닝 이용
            - `image.png?v=2`

## 무상태(stateless) 웹 계층

- 웹 계층을 수평적으로 확장하기 위해서는 상태 정보를 웹 계층에서 제거해야 한다
- 상태 정보를 DB에 저장하고, 필요할 때 가져오도록 하면 무상태 웹 계층을 달성할 수 있다

### 상태 정보 의존적인 아키텍처

- 상태 정보를 DB에 저장하지 않더라도 sticky session 등의 기능을 사용하면 웹 계층을 수평적으로 확장하는 것이 가능하다
- 하지만, 이는 LB에 부담을 주고 새롭게 서버를 추가하거나 제거하는 것이 어려워진다

### 무상태 아키텍처

- 무상태 아키텍처를 사용하면 단순하고, 안정적이며, 규모 확장이 쉽다

> JWT vs Session

- JWT
    - 장점
        - 세션과 다르개 Stateless가 가능하다
            - 따라서 확장성이 좋다
        - 토큰 안에 정보가 담겨있어 별도의 저장소가 필요 없다
        - 모바일도 동작 가능
    - 단점
        - 토큰이 유출되었을 때 서버 단에서 무효화할 수 없다
        - 데이터가 많아질수록 토큰의 길이가 길어지며, 이는 네트워크에 부담이 된다
        - 데이터가 암호화되지 않아 중요한 정보를 담을 수는 없다
- 세션
    - 장점
        - 서버 쪽에서 세션 통제 가능
        - 네트워크 부하가 낮다
            - 16 or 32 or ~~~~
    - 단점
        - 세션 저장소를 별도로 운영해야 한다는 단점이 있다
            - 과연 확장성이 문제가 되는 시점은 언제??

## 데이터 센터

- 다중 데이터 센터 아키텍처를 만들기 위해서는 아래와 같은 기술적 난제를 해결해야 한다
    - 트래픽 우회
        - 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 한다
        - Ex) GeoDNS
    - 데이터 동기화
        - 데이터센터마다 별도의 DB를 사용한다면 이를 다중화하는 방법이 필요하다
        - [Active-Active for Multi-Regional Resiliency | Netflix TechBlog](https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b)
    - 테스트와 배포
        - 여러 데이터 센터를 사용하는 경우 여러 데이터 센터에 효과적으로 배포하는 방법, 이를 테스트하는 방법이 필요하다

> GeoDNS

- AnyCast
    - 가장 가까운 DNS 서버가 IP 주소 응답
    - IP 주소에 대한 라우팅은 별도
- GeoDNS
    - 사용자의 IP 기반으로 위치 추정해서 DNS 응답을 결정
        - 위치 기반 거부도 가능

- Anycast와 GeoDNS를 결합하면
    - Anycast : 가장 가까운 DNS 서버 응답
    - GeoDNS : 지역적으로 가장 가까운 IP 응답

## 메시지 큐

- 시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하고, 각기 독립적으로 확장할 수 있도록 해야 한다
- MQ는 실제 분산 시스템이 이 문제를 풀기 위해서 채용하고 있는 핵심적 전략 중 하나다

- 메시지 큐는 메시지가 손실되지 않으면서 비동기 통신을 지원하는 컴포넌트
- 메시지 큐를 사용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성을 늘릴 수 있다
    - 생산자는 소비자가 다운되어 있어도 메시지 발행이 가능하며, 소비자는 생산자 서비스가 가용 상태가 아니더라도 메시지 수신이 가능하다
- 또한 큐에 쌓여있는 메시지 수에 따라서 프로세스의 수를 능동적으로 조작하는 것도 가능하다

## 로그, 메트릭 그리고 자동화

- 로그
    - 에러 로그를 모니터링하거나, 시스템의 오류나 문제를 보다 쉽게 찾아내고 분석할 수 있도록 해준다
- 메트릭
    - 메트릭을 잘 수집하면 비즈니스 적인 정보를 얻거나, 시스템의 현재 상태를 파악할 수 있다
- 자동화
    - 시스템이 크고 복잡해지면 생산성을 높이기 위해서 자동화 도구를 활용해야 한다
    - CI를 도와주는 도구를 활용하면 코드에 대한 검증을 자동화할 수 있고, 빌드나 배포 등의 과정 또한 자동화가 가능하다

### 메시지 큐, 로그, 메트릭, 자동화 등을 반영하여 수정한 설계안

- 내부적으로 버퍼 관리
    - 버퍼 내용을 인메모리나 디스크에 저장
    - 로그나 메모리 전송에 실패한 경우 복구해서 재전송

## 데이터베이스의 규모 확장

- 데이터베이스의 규모를 확장하는 방법은 두 가지가 있다
- 수직적 규모 확장, 수평적 규모 확장

### 수직적 확장

- 서버에 더 고성능의 자원을 사용하는 방법
- 만약 수직적 확장으로 처리가 가능하다면 나쁜 방법은 아니다. 하지만 이 방법에는 아래와 같은 단점이 존재한다
    - 수직적 확장에는 한계가 존재한다. 지금은 괜찮아도 나중에는 더 이상 버틸 수 없는 지점이 올 수도 있다
    - SPOF로 인한 위험성이 크다
    - 비용이 많이 든다

### 수평적 확장

- DB의 수평적 확장은 샤딩이라고도 한다
- 더 많은 서버를 추가함으로써 성능을 향상시킨다
- 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에 중복은 없다

- 샤딩은 규모 확장에 사용할 수 있는 효과적인 방법이지만 이로 인한 여러 문제점이 생길 수도 있고, 복잡성도 늘어난다
    - 데이터를 다시 샤딩하는 경우를 고려해야 한다
        - 데이터가 너무 많아져서 샤드를 추가해야 하는 경우 전략에 따라서 데이터를 다시 샤딩해야 할 수도 있다
        - 효과적인 샤드 전략을 사용하거나, consistent hashing 기법을 활용하여 이러한 문제를 줄일 수 있다
        - [Notion에서 Postgres를 샤딩하면서 얻은 교훈 (번역)](https://bluayer.com/66)
    - 유명인사 문제 혹은 핫스팟 키 문제를 고려해야 한다
        - 시스템에 따라서 특정 키 또는 키 범위에 요청이 몰리는 경우가 존재한다
        - 이를 잘 대응할 수 있도록 유명인사를 샤드에 나누거나, 이를 더 작은 사이즈로 자르거나 등의 작업이 필요하다
        - [트위터 시스템 디자인 실험기 ](https://hyeon9mak.github.io/twitter-system-design-experiment/)
    - 한 번 샤딩을 한 뒤에는 조인하기가 어렵다
        - 이를 해결하는 방법은 조인이 필요없도록 샤드를 구성하거나 데이터베이스를 비정규화하는 것이다

> 파티셔닝, 샤딩, 전략

- 파티닝
    - 왜 하나요
        - 테이블을 물리적으로 분리
        - 데이터 사이즈, 인덱스 크기 줄이기
            - 인덱스 전체가 메모리에 안 올라간다면?
        - 파일 나눠서 관리 -> 파일 손상 위험 낮추기
        - CUD 성능
    - 종류
        - 수평 파티셔닝
            - 행 단위 분리
            - 장점
                - 데이터 수 자체가 줄어들어 성능 향상
        - 수직 파티셔닝
            - 칼럼 단위 분리
            - 장점
                - 자주 사용되는 칼럼마 ㄴ조회
                - 같은 타입의 데이터 저장 -> 압축 효율
    - 범위 나누는 법
        - List
            - 데이터 값이 특정 목록
        - Range
            - 데이터 값이 특정 범위
        - Hash
            - 해시 값으로 판단
        - Composite
            - 위 종류를 여러 개 조합해서 사용
- 샤딩
    - 수평 파티셔닝의 일종
        - 스키마는 같지만 DB 서버가 독립적
    - 애플리케이션 단에서 샤딩, 데이터베이스 단, 미들웨어
        - 데이터베이스 : [Spider](https://mariadb.com/kb/en/spider-storage-engine-overview/)
        - 미들웨어 : ShardingSphere
        - PlanetScale?
    - 조인이 어렵다
    - Hot Spot 경계
    - 기법
        - Hash
            - 구현 간단, 데이터 균등 분배
            - 샤드 추가 및 제거시 데이터 재배치 필요
        - Range
            - 구현 간단
            - 데이터 균등 분배 X -> HotSpot
        - Directory Based
            - 동적 샤드 추가가 쉽다
            - Look Up Table SPOF

## 백만 사용자, 그리고 그 이상

- 시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정
- 이 챕터에서 살펴본 기법들은 다음과 같다
    - 웹 계층은 무상태 계층으로
    - 모든 계층에 다중화 도입
    - 가능한 한 많은 데이터를 캐싱
    - 여러 데이터 센터 지원
    - 정적 콘텐츠는 CDN으로 서빙
    - 데이터 계층은 샤딩을 통해 규모 확장
    - 각 계층은 독립적인 서비스로 분할
    - 시스템을 지속적으로 모니터링, 자동화 도구들을 활용

